{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0001 Twosum","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>1. TwoSum</h1>\n<ul>\n<li>ChunYu: May 02, 2020</li>\n<li>ID: 1</li>\n<li>Level: Easy</li>\n<li>Minyoung: May 02, 2020</li>\n<li>Tags: Recursion</li>\n</ul>\n<p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>\n<p>You may assume that each input would have <em><strong>exactly</strong></em> one solution, and you may not use the <em>same</em> element twice.</p>\n<p><strong>Example:</strong></p>\n<pre><code class=\"language-text\">Given nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n</code></pre>\n<h2>❌ 2-Pointer @shichunyu Shi May 02, 2020</h2>\n<p>time limit exceeded</p>\n<pre><code class=\"language-python\">class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        a = 0\n        b = 1\n        while a &#x3C; len(nums):\n            while b &#x3C; len(nums):\n                sum = nums[a] + nums[b]\n                if sum == target:\n                    ans = []\n                    ans.extend([a,b])\n                    return ans\n                else:\n                    b += 1\n            a += 1\n            b = a+1\n</code></pre>\n<h2>✅ Search for value left in list @shichunyu Shi May 02, 2020</h2>\n<p>Runtime: 1208 ms, faster than 24.87% of Python3 online submissions for Two Sum.</p>\n<p>Memory Usage: 14.8 MB, less than 13.95% of Python3 online submissions for Two Sum.</p>\n<pre><code class=\"language-python\">class Solution:\n    def twoSum(self, nums, target):\n        a = 0\n\n        while a &#x3C; len(nums):\n            left = target - nums[a]\n\n            if left != nums[a]:\n                if left in nums:\n                    b = nums.index(left)\n                    ans = []\n                    ans.extend([a, b])\n                    return ans\n                else:\n                    a += 1\n            else:\n                nums_temp = nums[a+1:]\n                if left in nums_temp:\n                    b = nums_temp.index(left)\n                    ans = []\n                    ans.extend([a, b+a+1])\n                    return ans\n                else:\n                    a += 1\n</code></pre>\n<h2>✅ Using Binary Search @shichunyu Shi May 02, 2020</h2>\n<p>Runtime: 60 ms, faster than 37.64% of Python3 online submissions for Two Sum.</p>\n<p>Memory Usage: 15.1 MB, less than 5.34% of Python3 online submissions for Two Sum.</p>\n<pre><code class=\"language-python\">class Solution:\n    def twoSum(self, nums, target):\n        sorted_nums = sorted(nums)\n\n        for i in range(len(sorted_nums)):\n            left = target - sorted_nums[i]\n            if left != 0 or (left == 0 and sorted_nums[i] != 0):\n                sub_nums = sorted_nums[i+1:]\n                values = self._binarySearch(i, sub_nums, target, left)\n                if values:\n                    x = values[0]\n                    x_value = sorted_nums[x]\n                    y_value = values[1]\n\n                    x_index = nums.index(x_value)\n                    y_index = nums.index(y_value)\n\n                    if x_index == y_index:\n                        new_nums = nums[x_index+1:]\n                        y_index = new_nums.index(y_value) + x_index + 1\n                        return [x_index, y_index]\n                    return [x_index, y_index]\n            else:\n                x_index = nums.index(0)\n                new_nums = nums[x_index+1:]\n                y_index = new_nums.index(0) + x_index + 1\n                return [x_index, y_index]\n\n        return -1\n\n    def _binarySearch(self, i, nums, target, left):\n        if len(nums) == 0:\n            return -1\n\n        lo = 0\n        hi = len(nums) - 1\n        while lo &#x3C;= hi:\n            mid = (lo + hi) // 2\n            if nums[mid] == left:\n                values = (i, nums[mid])\n                return values\n            elif nums[mid] &#x3C; left:\n                lo = mid + 1\n            else:\n                hi = mid - 1\n</code></pre>\n<h2>Use Memoization &#x26; Recursion</h2>\n<h3>✅ Brute Force @Minyoung An May 02, 2020</h3>\n<pre><code class=\"language-python\"># recursion\n# bruteforce: timeout\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        result = []\n        return self._helper(nums,target,result,0)\n\n    def _helper(self,nums,target,result,index):\n        if index == len(nums):\n            return result\n\n        # current num = nums[index]\n        num = nums[index]\n\n        # iterate over array and find match that does != same index\n        for i in range(len(nums)):\n            if index == i:\n                continue\n\n            # if num and num[i] == target push to result array\n            if num + nums[i] == target:\n                result.append(index)\n                result.append(i)\n                return result\n\n        return self._helper(nums,target,result,index+1)\n</code></pre>\n<h3>⭐ Elegant Solution - matchmaking / card finding game @Minyoung An May 02, 2020</h3>\n<pre><code class=\"language-python\"># hashmap\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        memo = {}\n        return self._helper(nums,target,memo,0)\n\n    def _helper(self,nums,target,memo,index):\n        if index == len(nums):\n            return []\n\n        # current num = nums[index]\n        num = nums[index]\n\n        if target - num in memo:\n            return [memo[target-num],index]\n        else:\n            memo[num] = index\n\n        return self._helper(nums,target,memo,index+1)\n</code></pre>"}},"pageContext":{"slug":"0001 Twosum"}}}