{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0070 Climbing Stairs","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>70. Climbing Stairs</h1>\n<p>Leetcode: <a href=\"https://leetcode.com/problems/climbing-stairs/\">https://leetcode.com/problems/climbing-stairs/</a> Tags: #DP #Recursion #Fibonacci Related: [[509. Fibonacci Number.md]]</p>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p>Note: Given n will be a positive integer.</p>\n<pre><code class=\"language-text\">Example 1:\n\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</code></pre>\n<pre><code class=\"language-text\">Example 2:\n\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</code></pre>\n<h2>Recusive Solution</h2>\n<h3>Intuition</h3>\n<ul>\n<li>At each step, there is a decision to either take one step, or two steps.</li>\n<li>The decision tree looks like the following, assuming we start on \"floor\" 0. </li>\n<li>The left branch is taking 1 step, the right branch is taking 2 steps. </li>\n<li>Each node represents the \"floor\" we are on after taking the step(s)</li>\n</ul>\n<pre><code class=\"language-text\">                                    0\n                /                                       \\\n                1                                        2\n        /                   \\                  /                   \\\n       2                     3                3                     4\n /         \\          /          \\     /          \\           /           \\\n3           4        4            5   4            5         5             6\n</code></pre>\n<p><strong>Insight:</strong> We can already see from the decision tree above that there are overlapping subproblems. For example:</p>\n<ul>\n<li>on both floor 1 and floor 0 we have to solve floor 2</li>\n<li>on both floor 1 and floor 2 we have to solve floor 3</li>\n</ul>\n<h3>Basic Recursive Solution</h3>\n<p>We can write a recursive function that goes through the tree: 1. The total number of paths = the total number of leaf nodes at the bottom of the tree 2. Our recursive function should return \"1\" or increment the answer by 1 whenever it reaches the top floor (which is the bottom of the tree). This is our <em>base case</em>. 3. Our recursive function should increment by \"1\" every time the top floor is reached.</p>\n<p><strong>Runtime:</strong> 2^n because at every step there are 2 possible decisions. <strong>Space:</strong> O(N) because the height of the recursion stack is of N</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        cur_floor = 0\n        ans = 0\n\n        ans = self.recursion(n, cur_floor, ans)\n        return ans\n\n    def recursion(self, n, cur_floor, ans):\n        if cur_floor == n:\n            ans += 1\n            return ans\n        if cur_floor &#x3C;= n-1:\n            ans = self.recursion(n, cur_floor+1, ans)\n        if cur_floor &#x3C;= n-2:\n            ans = self.recursion(n, cur_floor+2, ans)\n\n        return ans\n</code></pre>\n<h2>Recursion with Memoization</h2>\n<p>The previous solution has an exponential runtime, because we solve the same problems over and over. We can memoize the problems we already solved: 1. Every time we go up to a certain floor, cache the solution for that floor in the memo 2. When we revisit a floor, if that floor has already been cached, look up the solution in the memo.</p>\n<p><strong>Runtime:</strong> O(N) because we evaluate every single \"floor\" only once, and there are N floors <strong>Space:</strong> O(N) because we have the height of recursion stack is still N</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        cur_floor = 0\n        ans = 0\n        memo = {}\n\n        ans = self.recursion(n, cur_floor, ans, memo)\n        return ans\n\n    def recursion(self, n, cur_floor, ans, memo):\n        if cur_floor == n:\n            ans += 1\n            memo[cur_floor] = ans\n            return ans\n        if cur_floor in memo:\n            ans += memo[cur_floor]\n            return ans\n        else:\n            if cur_floor &#x3C;= n-1:\n                ans = self.recursion(n, cur_floor+1, ans, memo)\n                memo[cur_floor] = ans\n            if cur_floor &#x3C;= n-2:\n                ans = self.recursion(n, cur_floor+2, ans, memo)\n                memo[cur_floor] = ans\n        return ans\n</code></pre>\n<p><strong>A slightly different way to write the above code</strong> Here the top floor returns \"1\" instead of incrementing the answer by 1</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n    floor = 0\n    memo = {}\n\n    return recursion(n,floor,memo)\n\n    def recursion(n,floor,memo):\n        ans = 0\n        if floor in memo:\n            return memo[floor]\n        if floor == n:\n            return 1\n        if floor + 1 &#x3C;= n:\n            ans += recursion(n,floor+1,memo)\n        if floor + 2 &#x3C;= n:\n            ans += recursion(n,floor+2,memo)\n        memo[floor] = ans\n        return ans\n</code></pre>\n<h2>Fibonacci using Dynamic Programming</h2>\n<p>If we run our recursive solution on many values of n, we will begin to see a pattern</p>\n<pre><code class=\"language-text\">  n = 1,2,3,4,5, 6, 7, 8, 9,10\nans = 1,2,3,5,8,13,21,34,55,89\n</code></pre>\n<p>The sequence for <code>ans</code> is actually the fibonacci sequence.</p>\n<p><code>climbStairs(n) = climbStairs(n-1)+climbStairs(n-2)</code></p>\n<p>We can use this insight for a Dynamic Programming solution.</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        cur_floor = 1\n        table = []\n\n        while cur_floor &#x3C;= n:\n            if cur_floor == 1:\n                table.append(1)\n            elif cur_floor == 2:\n                table.append(2)\n            else:\n                cur_ans = table[cur_floor-2]+table[cur_floor-3]\n                table.append(cur_ans)\n            cur_floor += 1\n\n        return table[n-1]\n</code></pre>\n<h2>Pure Fibonacci Solution</h2>\n<p>Since the solution is a Fibonacci sequence, we don't even need to tabluate, and can save space by doing the same solution as [[509. Fibonacci Number.md]]</p>\n<p><strong>Runtime:</strong> O(N) because we have to evaluate N numbers <strong>Space:</strong> O(1) because we are only storing values in variables</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        first_step = 1\n        second_step = 2\n        third_step = 3\n        if n == 1:\n            return first_step\n        for i in range(3,n+1):\n            third_step = first_step + second_step\n            first_step = second_step\n            second_step = third_step\n        return second_step\n</code></pre>\n<p>Here is how the algorithm plays out:</p>\n<pre><code class=\"language-text\">climbStairs(5)\n\nfor 3:\n    third_step = 3\n    first_step = 2\n    second_step = 3\n\nfor 4:\n    third_step = 5\n    first_step = 3\n    second_step = 5\n\nfor 5:\n    third_step = 8\n    first_step = 5\n    second_step = 8\n\nreturn second_step // 8\n</code></pre>\n<blockquote>\n<p>Note: You may have noticed that by the time we hit the return, second_step = third_step. But the reason we return second_step instead of third_step is for the case where n = 2. In that case, we skip the for loop and return second_step = 2.</p>\n</blockquote>"}},"pageContext":{"slug":"0070 Climbing Stairs"}}}