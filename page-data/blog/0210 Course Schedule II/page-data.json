{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0210 Course Schedule II","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1 id=\"0210-course-schedule-ii\" style=\"position:relative;\"><a href=\"#0210-course-schedule-ii\" aria-label=\"0210 course schedule ii permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0210. Course Schedule II</h1>\n<h2 id=\"210-course-schedule-ii\" style=\"position:relative;\"><a href=\"#210-course-schedule-ii\" aria-label=\"210 course schedule ii permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>210. Course Schedule II</h2>\n<ul>\n<li>\n<p><a href=\"0210.-course-schedule-ii.md#210-course-schedule-ii\">210. Course Schedule II</a></p>\n<ul>\n<li><a href=\"0210.-course-schedule-ii.md#note\">Note:</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"0210.-course-schedule-ii.md#node-indegree-shichunyu-on-may-15-2020\">Node Indegree @shichunyu on May 15, 2020</a></p>\n<ul>\n<li><a href=\"0210.-course-schedule-ii.md#the-problem-is-a-topological-sort\">The problem is a topological sort</a></li>\n<li><a href=\"0210.-course-schedule-ii.md#setup\">Setup</a></li>\n<li><a href=\"0210.-course-schedule-ii.md#script\">Script</a></li>\n</ul>\n</li>\n<li><a href=\"0210.-course-schedule-ii.md#dfs-solution-leetcode\">DFS Solution (Leetcode)</a></li>\n</ul>\n<p>There are a total of n courses you have to take, labeled from 0 to n-1.</p>\n<p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</p>\n<p>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</p>\n<p>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>\n<pre><code class=\"language-text\">Example 1:\n\nInput: 2, [[1,0]] \nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished   \n             course 0. So the correct course order is [0,1] .\n</code></pre>\n<pre><code class=\"language-text\">Example 2:\n\nInput: 4, [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,1,2,3] or [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both     \n             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. \n             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .\n</code></pre>\n<h3 id=\"note\" style=\"position:relative;\"><a href=\"#note\" aria-label=\"note permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Note:</h3>\n<p>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented. You may assume that there are no duplicate edges in the input prerequisites.</p>\n<h2 id=\"node-indegree-shichunyu-on-may-15-2020\" style=\"position:relative;\"><a href=\"#node-indegree-shichunyu-on-may-15-2020\" aria-label=\"node indegree shichunyu on may 15 2020 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node Indegree @shichunyu on May 15, 2020</h2>\n<blockquote>\n<p><code>O(V+E) Time &#x26; Space Complexity</code> Runtime: 100 ms, faster than 85.76% of Python3 online submissions for Course Schedule II. Memory Usage: 15.1 MB, less than 60.71% of Python3 online submissions for Course Schedule II.</p>\n</blockquote>\n<h3 id=\"the-problem-is-a-topological-sort\" style=\"position:relative;\"><a href=\"#the-problem-is-a-topological-sort\" aria-label=\"the problem is a topological sort permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The problem is a topological sort</h3>\n<h4 id=\"setup\" style=\"position:relative;\"><a href=\"#setup\" aria-label=\"setup permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setup</h4>\n<ol>\n<li>Use input to count the # of pre-reqs per course -> num_prereqs = [...]</li>\n<li>Use input to create a dependencies dic -> depend = {...:...}</li>\n</ol>\n<pre><code class=\"language-python\">Input: 6, [[1,0],[2,0],[2,1],[3,1],[3,2],[4,2],[4,3],[5,1],[5,2],[5,4]]\nOutput: [0,1,2,3,4,5]\n\nprereqs = { # it turns out this is not necessary to build\n    0: None\n    1: 0\n    2: 0,1\n    3: 1,2\n    4: 2,3\n    5: 1,2,4\n}\n\nnum_prereqs = [0,1,2,2,2,3]\n\ndepend = {\n    0 : 1,2\n    1 : 2,3,5\n    2 : 3,4,5\n    3 : 4\n    4 : 5\n    5 : None \n}\n</code></pre>\n<h4 id=\"script\" style=\"position:relative;\"><a href=\"#script\" aria-label=\"script permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Script</h4>\n<ol>\n<li>\n<p>First find starting courses that has no pre-reqs</p>\n<pre><code class=\"language-text\">           0,1,2,3,4,5\nnum_prereqs = [0,1,2,2,2,3]\n</code></pre>\n</li>\n<li>\n<p>Add no-prereq courses to stack</p>\n<p>queue = []</p>\n</li>\n<li>\n<p>Add to Ans &#x26; remove from stack</p>\n<p>ans = []</p>\n</li>\n<li>Search what dependencies are now removed and count down the pre-reqs by 1</li>\n<li>If any counter reaches 0, add to queue</li>\n<li>When queue is empty stop processing</li>\n<li>Check if num_prereqs are all 0s</li>\n<li>\n<p>Go back to 1</p>\n<p>```python</p>\n<p>class Solution:</p>\n<p>def findOrder(self, numCourses, prerequisites):</p>\n<pre><code class=\"language-text\">\"\"\"\n:type numCourses: int\n:type prerequisites: List[List[int]]\n:rtype: List[int]\n\"\"\"\ndepend = {}\n# build our dependencies list -> we could have also used defaultdict here\nfor i in range(numCourses):\n    depend[i] = []\nfor i,j in prerequisites:\n    depend[j].append(i)\n# build our num_prereqs counter\nnum_prereqs = [0] * numCourses\nfor edge in prerequisites: #[1,0]\n    idx = edge[0]\n    num_prereqs[idx] += 1\n# set up our queue &#x26; answer\nans = []\nqueue = []\n# set up our starting queue\nfor idx in range(len(num_prereqs)):\n    if num_prereqs[idx] == 0:\n        queue.append(idx)\n# process the queue\nwhile queue:\n    ready_course = queue.pop()\n    ans.append(ready_course)\n    for dependency in depend[ready_course]:\n        num_prereqs[dependency] -= 1\n        if num_prereqs[dependency] == 0:\n            queue.append(dependency)\n# check if all edges have been removed. If not, then there is a cycle.\nif any(num_prereqs):\n    return []\nelse:\n    return ans\n</code></pre>\n</li>\n</ol>\n<p>s = Solution() print(s.findOrder(6,[[1,0],[2,0],[2,1],[3,1],[3,2],[4,2],[4,3],[5,1],[5,2],[5,4]]))</p>\n<pre><code class=\"language-text\"># DFS Solution (Leetcode)\n\n> `O(N) Time &#x26; Space Complexity`\n\n\n```python\nfrom collections import defaultdict\nclass Solution:\n\n    WHITE = 1\n    GRAY = 2\n    BLACK = 3\n\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n\n        # Create the adjacency list representation of the graph\n        adj_list = defaultdict(list) \n\n        # A pair [a, b] in the input represents edge from b --> a\n        for dest, src in prerequisites:\n            adj_list[src].append(dest) # defaultdict lets you insert missing keys. Here the key will just be inserted. \n\n        topological_sorted_order = []\n        is_possible = True\n\n        # By default all vertces are WHITE\n        color = {k: Solution.WHITE for k in range(numCourses)}\n        def dfs(node):\n            nonlocal is_possible # nonlocal allows you to change the global variable without having to pass it back and forth into the function.\n\n            # Don't recurse further if we found a cycle already\n            if not is_possible:\n                return\n\n            # Start the recursion\n            color[node] = Solution.GRAY\n\n            # Traverse on neighboring vertices\n            if node in adj_list:\n                for neighbor in adj_list[node]:\n                    if color[neighbor] == Solution.WHITE:\n                        dfs(neighbor)\n                    elif color[neighbor] == Solution.GRAY:\n                         # An edge to a GRAY vertex represents a cycle\n                        is_possible = False\n\n            # Recursion ends. We mark it as black\n            color[node] = Solution.BLACK\n            topological_sorted_order.append(node)\n\n        for vertex in range(numCourses):\n            # If the node is unprocessed, then call dfs on it.\n            if color[vertex] == Solution.WHITE:\n                dfs(vertex)\n\n        return topological_sorted_order[::-1] if is_possible else [] # reverses the array using [::-1]\n</code></pre>"}},"pageContext":{"slug":"0210 Course Schedule II"}}}