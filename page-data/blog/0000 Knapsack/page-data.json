{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0000 Knapsack","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>1/0 Knapsack Problem</h1>\n<ul>\n<li><a href=\"#10-knapsack-problem\">1/0 Knapsack Problem</a></li>\n<li>\n<p><a href=\"#top-down-recursive-apprach\">Top-Down Recursive Apprach</a></p>\n<ul>\n<li><a href=\"#intuition\">Intuition</a></li>\n<li><a href=\"#implementation\">Implementation</a></li>\n</ul>\n</li>\n<li><a href=\"#dynamic-programming-approach-shichunyu-on-may-29-2020\">Dynamic Programming Approach @shichunyu on May 29, 2020</a></li>\n</ul>\n<p>See the question here referenced at <a href=\"https://www.byte-by-byte.com/01knapsack/\">Byte-to-Byte</a></p>\n<p>Given a list of items with values and weights, as well as a max weight, find the maximum value you can generate from items where the sum of the weights is less than the max.</p>\n<pre><code>Example:\n\nitems = {(w:1, v:6), (w:2, v:10), (w:3, v:12)}\nmaxWeight = 5\nknapsack(items, maxWeight) = 22\n</code></pre>\n<h1>Top-Down Recursive Apprach</h1>\n<h2>Intuition</h2>\n<ul>\n<li>We can start with a full knapsack</li>\n<li>If the knapsack is NOT over capacity, then we have our answer - every item should be added.</li>\n<li>If the knapsack IS over capacity, then we have to take out an item. Which item do we remove?</li>\n<li>We can remove any of the items, so we have n possible branches in our decision tree.</li>\n</ul>\n<pre><code>                                                         (1,6) (2,10) (3,12) (2,4) w:6 v:28\n              /                                       |                                        |                                       \\\n(2,10) (3,12) (2,4) w:7 v:26            (1,6) (3,12) (2,4) w:6 v:22               (1,6) (2,10) (2,4) w:5 v:20              (1,6) (2,10) (3,12) w:6 v:28\n</code></pre>\n<ul>\n<li>The third branch from the left has already meet the weight limit, so we are going to leave it as is.</li>\n<li>For all the other branches, we need to keep removing items</li>\n</ul>\n<blockquote>\n<p>For the purposes of saving space, I am going to hide the 3rd branch from the graph for now, and use its vale as the placeholder</p>\n</blockquote>\n<pre><code>                                                         (1,6) (2,10) (3,12) (2,4) w:6 v:28\n                  /                                                       |                      |                                    \\\n   (2,10) (3,12) (2,4) w:7 v:26                              (1,6) (3,12) (2,4) w:6 v:22       V:20                      (1,6) (2,10) (3,12) w:6 v:28\n    /            |           \\                               /            |           \\                                   /            |           \\  \n(3,12) (2,4) (2,10) (2,4) (2,10) (3,12)               (3,12) (2,4)   (1,6) (2,4)    (1,6) (3,12)                   (2,10) (3,12)  (1,6) (3,12)  (1,6) (2,10)\n  w:5 v:16     w:4 v:14     w:5 v:12                    w:5 v:16       w:3 v:6        w:4 v:18                       w:5 v:22       w:4 v:18      w:3 v:16\n</code></pre>\n<ul>\n<li>We can see that all of the leaf nodes now are within the weight limit.</li>\n<li>Now we just have to pick the leaf node with the highest value, and find the answer.</li>\n<li>Note that we have that \"placeholder\" leaf node with v:20 as well. It should be considered along with the other leaf nodes.</li>\n<li>The leaf node with the highest value is the one with v:22. </li>\n<li>So, the leaf node is (2,10) (3,12) with w:5 v:22.</li>\n<li>For this question we would return the value \"22\" as the answer.</li>\n</ul>\n<h2>Implementation</h2>\n<ul>\n<li>This lends itself naturally to a recursive tree traversal, where the base case is that the weight limit is no longer exceeded.</li>\n<li>Note that there is the opportunity for memoization, because a lot of the problems are solved more than once.</li>\n<li>For example, in the 2nd diagram, you can find the pair (1,6) (2,4) multiple times, as well as (3,12) (2,4), etc.</li>\n<li>The downstream branches are the same for all the repeating pairs, so there is no need to re-calculate them each time</li>\n</ul>\n<p><strong>Algorithm Steps:</strong></p>\n<ol>\n<li>Start at the original array. If the weight limit is not exceeded, simply return the total value as the answer.</li>\n<li>Have a recursive call for each item in the remaining array, where the item is removed to form a new array</li>\n<li>The new array must be passed downstream to its own recursive calls, so that the array gets smaller and smaller</li>\n<li>At each recursive call stack layer, the value of the array must be compared the the maximum value we have encountered so far. The greater of the two is saved.</li>\n<li>Repeat until there are no more leaf nodes with weight exceeding the limit.</li>\n</ol>\n<p>A good exmaple explaining the time complexity from <a href=\"https://www.educative.io/courses/grokking-dynamic-programming-patterns-for-coding-interviews/RM1BDv71V60#top-down-dynamic-programming-with-memoization\">Educative</a></p>\n<p><strong>Runtime:</strong> O(N*M) where N = num of items and M = max_weight<br>\n<strong>Space:</strong> O(N*M) as well for storing the dictionary</p>\n<pre><code class=\"language-py\"># items = {(w:1, v:6), (w:2, v:10), (w:3, v:12)}\n# maxWeight = 5\n# knapsack(items, maxWeight) = 22\n\nclass Solution:\n    def knapsack(self, items, max_weight):\n        \"\"\"\n        items type: List[tuple()]\n        maxWeight type: int\n        rtype: int\n\n        returns the maxValue possible from putting items into knapsack without going over the maxWeight\n        \"\"\"\n        max_value = float('-inf')\n        cur_weight = 0\n        cur_value = 0\n        memo = {}\n\n        for item in items:\n            cur_weight += item[0]\n            cur_value += item[1]\n        # print(cur_weight)\n        # print(cur_value)\n        if cur_weight &#x3C;= max_weight:\n            return cur_value\n        else:\n            ans = self._recursion(items, max_weight, cur_weight, cur_value, max_value, memo)\n            # print(memo)\n            return ans\n        \n    def _recursion(self, items, max_weight, cur_weight, cur_value, max_value, memo):\n        for i in range(len(items)):\n            new_items = items[:]\n            new_weight = cur_weight\n            new_value = cur_value\n            new_weight -= items[i][0]\n            new_value -= items[i][1]\n            # print(new_items)\n            # print(new_weight)\n            # print(new_value)\n            if new_weight &#x3C;= max_weight:\n                max_value = max(new_value, max_value)\n                max_value = max(new_value, max_value)   \n            else:\n                if (tuple(new_items)) in memo:\n                    max_value = max_value = max(memo[tuple(new_items)], max_value)\n                del new_items[i]\n                max_value = self._recursion(new_items, max_weight, new_weight, new_value, max_value, memo)\n        memo[tuple(items)] = max_value\n        return max_value\n                \ns = Solution()\nitems = [(1, 6), (2, 10), (3, 12)]\nprint(s.knapsack(items, 5)) # 22\nitems = [(10,60),(20,100),(30,120)]\nprint(s.knapsack(items, 50)) # 220\nitems = [(5,10),(4,40),(6,30),(3,50)]\nprint(s.knapsack(items, 10)) # 90\nitems = [(1,10),(2,15),(3,40)]\nprint(s.knapsack(items, 6)) # 65\nitems = [(1,1),(2,6),(5,18),(6,22),(7,25)]\nprint(s.knapsack(items, 11)) # 40\nitems = [(1,20),(2,5),(3,10),(8,40),(7,15),(4,25)]\nprint(s.knapsack(items, 10)) # 60\nitems = [(5,10),(4,40),(6,30),(3,50)]\nprint(s.knapsack(items, 10)) # 90\n</code></pre>\n<h1>Dynamic Programming Approach @shichunyu on May 29, 2020</h1>\n<p>m is the width and n is the height of the DP table</p>\n<p><strong>Runtime:</strong> O(mxn) because we visit each cell of the table once<br>\n<strong>Space:</strong> O(mxn) where we build a table of mxn size</p>\n<p>Great explanation: <a href=\"https://www.youtube.com/watch?v=xCbYmUPvc2Q\">Back-to-Back SWE</a> and AlgoExpert.io</p>\n<p>Here is what the DP table looks like for our solution:</p>\n<pre><code>[       0  1   2   3   4   5\n       [0, 0,  0,  0,  0,  0], \n(1, 6) [0, 6,  6,  6,  6,  6], \n(2,10) [0, 6, 10, 16, 16, 16], \n(3,12) [0, 6, 10, 16, 18, 22]\n]\n</code></pre>\n<pre><code class=\"language-py\">class Solution:\n    def knapsack(self, items, max_weight):\n        \"\"\"\n        items type: List[tuple()]\n        maxWeight type: int\n        rtype: int\n\n        returns the maxValue possible from putting items into knapsack without going over the maxWeight\n        \"\"\"\n        # Create our table with 1 extra width &#x26; height to account for 0 and []\n        table_width = max_weight + 1\n        table_height = len(items) + 1\n        table = [[0] * table_width for _ in range(table_height)]\n        # print(table)\n        # print(table_width,table_height)\n\n        # Iterative through table, skipping the first row because we know [] is always 0 value\n        for i in range(1,table_height):\n            cur_weight = items[i-1][0]\n            cur_val = items[i-1][1]\n            # go through all the knapsack sizes\n            for j in range(table_width):\n                prev_val = table[i-1][j]\n                if j &#x3C; cur_weight:\n                    table[i][j] = prev_val\n                else:\n                    new_val = table[i-1][j-cur_weight] + cur_val\n                    table[i][j] = max(new_val, prev_val)\n        \n        # print(table)\n        return table[-1][-1]\n\n\ns = Solution()\nitems = [(1,6),(2,10),(3,12)]\nprint(s.knapsack(items,5))\n</code></pre>"}},"pageContext":{"slug":"0000 Knapsack"}}}