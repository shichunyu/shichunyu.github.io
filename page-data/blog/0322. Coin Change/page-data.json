{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0322. Coin Change","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1 id=\"0322-coin-change\" style=\"position:relative;\"><a href=\"#0322-coin-change\" aria-label=\"0322 coin change permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>0322. Coin Change</h1>\n<p>Tags: #_study/algos\nRelated To: [[0518. Coin Change II]]\nBacklinks: </p>\n<hr>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<pre><code>Example 1:\n\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 \nExplanation: 11 = 5 + 5 + 1\n</code></pre>\n<pre><code>Example 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nNote:\nYou may assume that you have an infinite number of each kind of coin.\n</code></pre>\n<h1 id=\"dynamic-programming-bottom-up\" style=\"position:relative;\"><a href=\"#dynamic-programming-bottom-up\" aria-label=\"dynamic programming bottom up permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming (Bottom-Up)</h1>\n<p><img src=\"0322.%20Coin%20Change/image.png\"></p>\n<h2 id=\"may-31-2020\" style=\"position:relative;\"><a href=\"#may-31-2020\" aria-label=\"may 31 2020 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>May 31, 2020</h2>\n<p>Runtime: O(a*c) where a = amount, c = number of coins\nSpace: O(a) where a = amount</p>\n<pre><code class=\"language-py\">class Solution:\n    def coinChange(self, coins, amount):\n        \"\"\"\n        For a given set of coin denomations, return the smallest number of coins that can be used to add up to a given target amount.\n        coins type: List[int]\n        amount type: int\n        rtype: int\n        \"\"\"\n        ways = [float('inf')]*(amount+1)\n        ways[0] = 0\n        for c in coins:\n            for i in range(1,amount+1):\n                if i >= c:\n                    ways[i] = min(ways[i],ways[i-c]+1)\n        # print(ways)\n        if ways[-1] == float('inf'):\n            return -1\n        return ways[-1]\n\n\ns = Solution()\nprint(s.coinChange([1],2)) # 2\nprint(s.coinChange([2],1)) # -1\nprint(s.coinChange([2],3)) # -1\nprint(s.coinChange([2,3],4)) # 2\nprint(s.coinChange([1,2,5],11)) # 3\nprint(s.coinChange([2, 5, 10, 1],27)) # 4\nprint(s.coinChange([1,2,5],100))  # 20\nprint(s.coinChange([431,62,88,428],9084))  # 26\n</code></pre>\n<h1 id=\"recursion-w-memoization-top-down\" style=\"position:relative;\"><a href=\"#recursion-w-memoization-top-down\" aria-label=\"recursion w memoization top down permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursion w/ Memoization (Top-Down)</h1>\n<p>Good explanation: <a href=\"https://www.youtube.com/watch?v=jgiZlGzXMBw\">Back-to-Back SWE</a>\n<img src=\"0322.%20Coin%20Change/image%202.png\"></p>\n<h2 id=\"bfs-using-dictionary---may-31-2020\" style=\"position:relative;\"><a href=\"#bfs-using-dictionary---may-31-2020\" aria-label=\"bfs using dictionary   may 31 2020 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BFS Using Dictionary - May 31, 2020</h2>\n<p> <strong>Runtime:</strong>  O(a*c) where a = amount, c = number of coins (forks in the tree)\n<strong>Space:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)</p>\n<pre><code class=\"language-py\">class Solution:\n    def coinChange(self, coins, amount):\n        \"\"\"\n        For a given set of coin denomations, return the smallest number of coins that can be used to add up to a given target amount.\n        coins type: List[int]\n        amount type: int\n        rtype: int\n        \"\"\"\n        if amount == 0:\n            return 0\n\n        levels = {1:[]}\n        visited = set()\n        cur_level = 1\n        found = False\n        \n        for c in coins:\n            levels[1].append(c)\n        # print(levels)\n\n        while found == False:\n            for item in levels[cur_level]:\n                if item in visited:\n                    continue\n                if item == amount:\n                    return cur_level\n                elif item > amount:\n                    continue\n                else:\n                    if (cur_level + 1) not in levels:\n                        levels[cur_level+1]=[]\n                    for c in coins:\n                        levels[cur_level+1].append(item + c)\n                    # print(levels)\n                visited.add(item)\n            cur_level += 1\n            if cur_level not in levels:\n                return -1\n\ns = Solution()\nprint(s.coinChange([1],2)) # 2\nprint(s.coinChange([2],1)) # -1\nprint(s.coinChange([2],3)) # -1\nprint(s.coinChange([2,3],4)) # 2\nprint(s.coinChange([1,2,5],11)) # 3\nprint(s.coinChange([2,5,10,1],27)) # 4\nprint(s.coinChange([1,2,5],100))  # 20\nprint(s.coinChange([431,62,88,428],9084))  # 26\n</code></pre>\n<h2 id=\"using-bfs-queue\" style=\"position:relative;\"><a href=\"#using-bfs-queue\" aria-label=\"using bfs queue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using BFS Queue</h2>\n<p>The above dictionary solution can also be implemented with a Queue, but it looks like the space &#x26; time complexity has no improvement.</p>\n<p><strong>Runtime:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)\n<strong>Space:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)</p>\n<hr>\n<h3 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>References</h3>\n<ul>\n<li>Top-Down Approach: <a href=\"https://www.youtube.com/watch?v=jgiZlGzXMBw\">Back-to-Back SWE</a></li>\n</ul>"}},"pageContext":{"slug":"0322. Coin Change"}}}