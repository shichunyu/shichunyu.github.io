{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0322. Coin Change","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>0322. Coin Change</h1>\n<p>Tags: #_study/algos\nRelated To: [[0518. Coin Change II]]\nBacklinks: </p>\n<hr>\n<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>\n<pre><code>Example 1:\n\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3 \nExplanation: 11 = 5 + 5 + 1\n</code></pre>\n<pre><code>Example 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nNote:\nYou may assume that you have an infinite number of each kind of coin.\n</code></pre>\n<h1>Dynamic Programming (Bottom-Up)</h1>\n<p><img src=\"0322.%20Coin%20Change/image.png\"></p>\n<h2>May 31, 2020</h2>\n<p>Runtime: O(a*c) where a = amount, c = number of coins\nSpace: O(a) where a = amount</p>\n<pre><code class=\"language-py\">class Solution:\n    def coinChange(self, coins, amount):\n        \"\"\"\n        For a given set of coin denomations, return the smallest number of coins that can be used to add up to a given target amount.\n        coins type: List[int]\n        amount type: int\n        rtype: int\n        \"\"\"\n        ways = [float('inf')]*(amount+1)\n        ways[0] = 0\n        for c in coins:\n            for i in range(1,amount+1):\n                if i >= c:\n                    ways[i] = min(ways[i],ways[i-c]+1)\n        # print(ways)\n        if ways[-1] == float('inf'):\n            return -1\n        return ways[-1]\n\n\ns = Solution()\nprint(s.coinChange([1],2)) # 2\nprint(s.coinChange([2],1)) # -1\nprint(s.coinChange([2],3)) # -1\nprint(s.coinChange([2,3],4)) # 2\nprint(s.coinChange([1,2,5],11)) # 3\nprint(s.coinChange([2, 5, 10, 1],27)) # 4\nprint(s.coinChange([1,2,5],100))  # 20\nprint(s.coinChange([431,62,88,428],9084))  # 26\n</code></pre>\n<h1>Recursion w/ Memoization (Top-Down)</h1>\n<p>Good explanation: <a href=\"https://www.youtube.com/watch?v=jgiZlGzXMBw\">Back-to-Back SWE</a>\n<img src=\"0322.%20Coin%20Change/image%202.png\"></p>\n<h2>BFS Using Dictionary - May 31, 2020</h2>\n<p> <strong>Runtime:</strong>  O(a*c) where a = amount, c = number of coins (forks in the tree)\n<strong>Space:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)</p>\n<pre><code class=\"language-py\">class Solution:\n    def coinChange(self, coins, amount):\n        \"\"\"\n        For a given set of coin denomations, return the smallest number of coins that can be used to add up to a given target amount.\n        coins type: List[int]\n        amount type: int\n        rtype: int\n        \"\"\"\n        if amount == 0:\n            return 0\n\n        levels = {1:[]}\n        visited = set()\n        cur_level = 1\n        found = False\n        \n        for c in coins:\n            levels[1].append(c)\n        # print(levels)\n\n        while found == False:\n            for item in levels[cur_level]:\n                if item in visited:\n                    continue\n                if item == amount:\n                    return cur_level\n                elif item > amount:\n                    continue\n                else:\n                    if (cur_level + 1) not in levels:\n                        levels[cur_level+1]=[]\n                    for c in coins:\n                        levels[cur_level+1].append(item + c)\n                    # print(levels)\n                visited.add(item)\n            cur_level += 1\n            if cur_level not in levels:\n                return -1\n\ns = Solution()\nprint(s.coinChange([1],2)) # 2\nprint(s.coinChange([2],1)) # -1\nprint(s.coinChange([2],3)) # -1\nprint(s.coinChange([2,3],4)) # 2\nprint(s.coinChange([1,2,5],11)) # 3\nprint(s.coinChange([2,5,10,1],27)) # 4\nprint(s.coinChange([1,2,5],100))  # 20\nprint(s.coinChange([431,62,88,428],9084))  # 26\n</code></pre>\n<h2>Using BFS Queue</h2>\n<p>The above dictionary solution can also be implemented with a Queue, but it looks like the space &#x26; time complexity has no improvement.</p>\n<p><strong>Runtime:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)\n<strong>Space:</strong> O(a*c) where a = amount, c = number of coins (forks in the tree)</p>\n<hr>\n<h3>References</h3>\n<ul>\n<li>Top-Down Approach: <a href=\"https://www.youtube.com/watch?v=jgiZlGzXMBw\">Back-to-Back SWE</a></li>\n</ul>"}},"pageContext":{"slug":"0322. Coin Change"}}}