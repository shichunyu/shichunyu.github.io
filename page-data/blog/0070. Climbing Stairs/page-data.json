{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0070. Climbing Stairs","result":{"data":{"markdownRemark":{"frontmatter":{"title":"70. Climbing Stairs","date":"2020-06–02"},"html":"<div class=\"toc\">\n<ul>\n<li><a href=\"#description\">Description</a></li>\n<li>\n<p><a href=\"#recursive-solutions\">Recursive Solutions</a></p>\n<ul>\n<li><a href=\"#intuition\">Intuition</a></li>\n<li><a href=\"#basic-recursive-solution-o2n--on\">Basic Recursive Solution: O(2<sup>n</sup>) / O(n)</a></li>\n<li><a href=\"#recursion-with-memoization-on--on\">Recursion with Memoization: O(n) / O(n)</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#dynamic-programming-solutions\">Dynamic Programming Solutions</a></p>\n<ul>\n<li><a href=\"#linear-space---tabulation-on--on\">Linear Space - Tabulation: O(n) / O(n)</a></li>\n<li><a href=\"#constant-space---pure-fibonacci-on--o1\">Constant Space - Pure Fibonacci: O(n) / O(1)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"description\" style=\"position:relative;\"><a href=\"#description\" aria-label=\"description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h1>\n<p>You are climbing a stair case. It takes n steps to reach to the top.</p>\n<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>\n<p>Note: Given n will be a positive integer.</p>\n<pre><code class=\"language-text\">Example 1:\n\nInput: 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n</code></pre>\n<pre><code class=\"language-text\">Example 2:\n\nInput: 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n</code></pre>\n<h1 id=\"recursive-solutions\" style=\"position:relative;\"><a href=\"#recursive-solutions\" aria-label=\"recursive solutions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursive Solutions</h1>\n<h2 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h2>\n<ul>\n<li>At each step, there is a decision to either take one step, or two steps.</li>\n<li>The decision tree looks like the following, assuming we start on “floor” 0.</li>\n<li>The left branch is taking 1 step, the right branch is taking 2 steps.</li>\n<li>Each node represents the “floor” we are on after taking the step(s)</li>\n</ul>\n<pre><code class=\"language-text\">                                    0\n                /                                       \\\n                1                                        2\n        /                   \\                  /                   \\\n       2                     3                3                     4\n /         \\          /          \\     /          \\           /           \\\n3           4        4            5   4            5         5             6\n</code></pre>\n<p><strong>Insight:</strong> We can already see from the decision tree above that there are overlapping subproblems. For example:</p>\n<ul>\n<li>on both floor 1 and floor 0 we have to solve floor 2</li>\n<li>on both floor 1 and floor 2 we have to solve floor 3</li>\n</ul>\n<h2 id=\"basic-recursive-solution-o2n--on\" style=\"position:relative;\"><a href=\"#basic-recursive-solution-o2n--on\" aria-label=\"basic recursive solution o2n  on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Basic Recursive Solution: O(2<sup>n</sup>) / O(n)</h2>\n<p>We can write a recursive function that goes through the tree: 1. The total number of paths = the total number of leaf nodes at the bottom of the tree 2. Our recursive function should return “1” or increment the answer by 1 whenever it reaches the top floor (which is the bottom of the tree). This is our <em>base case</em>. 3. Our recursive function should increment by “1” every time the top floor is reached.</p>\n<p><strong>Runtime:</strong> 2<sup>n</sup> because at every step there are 2 possible decisions.\n<strong>Space:</strong> O(n) because the height of the recursion stack is n</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        cur_floor = 0\n        ans = 0\n\n        ans = self.recursion(n, cur_floor, ans)\n        return ans\n\n    def recursion(self, n, cur_floor, ans):\n        if cur_floor == n:\n            ans += 1\n            return ans\n        if cur_floor &#x3C;= n-1:\n            ans = self.recursion(n, cur_floor+1, ans)\n        if cur_floor &#x3C;= n-2:\n            ans = self.recursion(n, cur_floor+2, ans)\n\n        return ans\n</code></pre>\n<h2 id=\"recursion-with-memoization-on--on\" style=\"position:relative;\"><a href=\"#recursion-with-memoization-on--on\" aria-label=\"recursion with memoization on  on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursion with Memoization: O(n) / O(n)</h2>\n<p>The previous solution has an exponential runtime, because we solve the same problems over and over. We can memoize the problems we already solved: 1. Every time we go up to a certain floor, cache the solution for that floor in the memo 2. When we revisit a floor, if that floor has already been cached, look up the solution in the memo.</p>\n<p><strong>Runtime:</strong> O(N) because we evaluate every single “floor” only once, and there are N floors <strong>Space:</strong> O(N) because we have the height of recursion stack is still N</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        cur_floor = 0\n        ans = 0\n        memo = {}\n\n        ans = self.recursion(n, cur_floor, ans, memo)\n        return ans\n\n    def recursion(self, n, cur_floor, ans, memo):\n        if cur_floor == n:\n            ans += 1\n            memo[cur_floor] = ans\n            return ans\n        if cur_floor in memo:\n            ans += memo[cur_floor]\n            return ans\n        else:\n            if cur_floor &#x3C;= n-1:\n                ans = self.recursion(n, cur_floor+1, ans, memo)\n                memo[cur_floor] = ans\n            if cur_floor &#x3C;= n-2:\n                ans = self.recursion(n, cur_floor+2, ans, memo)\n                memo[cur_floor] = ans\n        return ans\n</code></pre>\n<p><strong>A slightly different way to write the above code</strong> Here the top floor returns “1” instead of incrementing the answer by 1</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n    floor = 0\n    memo = {}\n\n    return recursion(n,floor,memo)\n\n    def recursion(n,floor,memo):\n        ans = 0\n        if floor in memo:\n            return memo[floor]\n        if floor == n:\n            return 1\n        if floor + 1 &#x3C;= n:\n            ans += recursion(n,floor+1,memo)\n        if floor + 2 &#x3C;= n:\n            ans += recursion(n,floor+2,memo)\n        memo[floor] = ans\n        return ans\n</code></pre>\n<h1 id=\"dynamic-programming-solutions\" style=\"position:relative;\"><a href=\"#dynamic-programming-solutions\" aria-label=\"dynamic programming solutions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming Solutions</h1>\n<h2 id=\"linear-space---tabulation-on--on\" style=\"position:relative;\"><a href=\"#linear-space---tabulation-on--on\" aria-label=\"linear space   tabulation on  on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Linear Space - Tabulation: O(n) / O(n)</h2>\n<p>If we run our recursive solution on many values of n, we will begin to see a pattern</p>\n<pre><code class=\"language-text\">  n = 1,2,3,4,5, 6, 7, 8, 9,10\nans = 1,2,3,5,8,13,21,34,55,89\n</code></pre>\n<p>The sequence for <code>ans</code> is actually the fibonacci sequence.</p>\n<p><code>climbStairs(n) = climbStairs(n-1)+climbStairs(n-2)</code></p>\n<p>We can use this insight for a Dynamic Programming solution.</p>\n<p><strong>Runtime:</strong> O(n) because we have to evaluate n numbers\n<strong>Space:</strong> O(n) because we are storing an array of length n</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        class Solution:\n    def climbStairs(self, n):\n        ways = [1,1]\n        for i in range(2,n+1):\n            ways.append(ways[i-1] + ways[i-2])\n        print(ways)\n        return ways[-1]\n\ns = Solution()\nprint(s.climbStairs(5))\n</code></pre>\n<h2 id=\"constant-space---pure-fibonacci-on--o1\" style=\"position:relative;\"><a href=\"#constant-space---pure-fibonacci-on--o1\" aria-label=\"constant space   pure fibonacci on  o1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constant Space - Pure Fibonacci: O(n) / O(1)</h2>\n<p>Since the solution is a Fibonacci sequence, we don’t even need to tabluate, and can save space by doing the same solution as [[509. Fibonacci Number.md]]</p>\n<p><strong>Runtime:</strong> O(n) because we have to evaluate N numbers\n<strong>Space:</strong> O(1) because we are only storing values in variables</p>\n<pre><code class=\"language-python\">class Solution:\n    def climbStairs(self, n):\n        \"\"\"\n        Returns the total number of possible ways to climb stairs by taking either 1 step or 2 steps at each steps. n is the number of total steps.\n        n type: int\n        rtype: int\n        \"\"\"\n        first_step = 1\n        second_step = 2\n        third_step = 3\n        if n == 1:\n            return first_step\n        for i in range(3,n+1):\n            third_step = first_step + second_step\n            first_step = second_step\n            second_step = third_step\n        return second_step\n</code></pre>\n<p>Here is how the algorithm plays out:</p>\n<pre><code class=\"language-text\">climbStairs(5)\n\nfor 3:\n    third_step = 3\n    first_step = 2\n    second_step = 3\n\nfor 4:\n    third_step = 5\n    first_step = 3\n    second_step = 5\n\nfor 5:\n    third_step = 8\n    first_step = 5\n    second_step = 8\n\nreturn second_step // 8\n</code></pre>\n<blockquote>\n<p>Note: You may have noticed that by the time we hit the return, second<em>step = third</em>step. But the reason we return second<em>step instead of third</em>step is for the case where n = 2. In that case, we skip the for loop and return second_step = 2.  </p>\n</blockquote>\n<hr>\n<p><strong>Question Source:</strong> <a href=\"https://leetcode.com/problems/climbing-stairs/\">Leetcode</a></p>"}},"pageContext":{"slug":"0070. Climbing Stairs"}}}