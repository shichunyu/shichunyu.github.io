{"componentChunkName":"component---src-templates-blog-js","path":"/blog/45_Jump_Game_II","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Jump Game II","date":"2020.06.01","number":45},"html":"<div class=\"toc\">\n<ul>\n<li>\n<p><a href=\"#overview\">Overview</a></p>\n<ul>\n<li><a href=\"#sources\">Sources</a></li>\n<li><a href=\"#description\">Description</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#brute-force-solutions\">Brute Force Solutions</a></p>\n<ul>\n<li><a href=\"#intuition\">Intuition</a></li>\n<li><a href=\"#brute-force-on2--on---time-limit-exceeded\">Brute Force: O(n<sup>2</sup>) / O(n) - Time Limit Exceeded</a></li>\n<li><a href=\"#brute-force-slightly-optimized---time-limit-exceeded\">Brute Force, slightly optimized - Time Limit Exceeded</a></li>\n<li><a href=\"#recursive-backtracking---not-working\">Recursive Backtracking - Not Working</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#dynamic-programming-solution\">Dynamic Programming Solution</a></p>\n<ul>\n<li><a href=\"#intuition-1\">Intuition</a></li>\n<li><a href=\"#dp-code-on--o1\">DP Code: O(n) / O(1)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<h1 id=\"overview\" style=\"position:relative;\"><a href=\"#overview\" aria-label=\"overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Overview</h1>\n<h2 id=\"sources\" style=\"position:relative;\"><a href=\"#sources\" aria-label=\"sources permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Sources</h2>\n<p>Question Source: <a href=\"https://leetcode.com/problems/jump-game-ii\">Leetcode</a><br>\nResources: AlgoExpert.io</p>\n<h2 id=\"description\" style=\"position:relative;\"><a href=\"#description\" aria-label=\"description permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Description</h2>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p>\n<p>Each element in the array represents your maximum jump length at that position.</p>\n<p>Your goal is to reach the last index in the minimum number of jumps.</p>\n<pre><code>Example:\n\nInput: [2, 3, 1, 1, 4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2.\nJump 1 step from index 0 to 1, then 3 steps to the last index.\n</code></pre>\n<blockquote>\n<p>Note: You can assume that you can always reach the last index.  </p>\n</blockquote>\n<h1 id=\"brute-force-solutions\" style=\"position:relative;\"><a href=\"#brute-force-solutions\" aria-label=\"brute force solutions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Brute Force Solutions</h1>\n<h2 id=\"intuition\" style=\"position:relative;\"><a href=\"#intuition\" aria-label=\"intuition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h2>\n<p>For every index of the array, we can calculate what is the minimum number of steps to arrive at that index from previous indices. By calculating previous indices, we can find the min # of jumps for the final index, which is our answer.</p>\n<h2 id=\"brute-force-on2--on---time-limit-exceeded\" style=\"position:relative;\"><a href=\"#brute-force-on2--on---time-limit-exceeded\" aria-label=\"brute force on2  on   time limit exceeded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Brute Force: O(n<sup>2</sup>) / O(n) - Time Limit Exceeded</h2>\n<p>Time Complexity: where <em>n</em> is the length of input array.</p>\n<pre><code class=\"language-py\"> 0. 1. 2. 3. 4. \n[2, 3, 1, 1, 4]\n 0  1  1  2  2\n\nclass Solution:\n    def jump(self, nums):\n        n = len(nums) #2\n        jumps = [float('inf')] * n # [inf,inf]\n        jumps[0] = 0 # [0,-inf]\n        for i in range(n-1): # 0,1\n            for j in range(1,nums[i]+1): # 1->1\n                if i+j &#x3C;= n-1:\n                    jumps[i+j] = min(jumps[i]+1,jumps[i+j])\n        return jumps[n-1]\n</code></pre>\n<h2 id=\"brute-force-slightly-optimized---time-limit-exceeded\" style=\"position:relative;\"><a href=\"#brute-force-slightly-optimized---time-limit-exceeded\" aria-label=\"brute force slightly optimized   time limit exceeded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Brute Force, slightly optimized - Time Limit Exceeded</h2>\n<p>The below optimization results in a constance improvement in time complexity, so the final time complexity is still O(n<sup>2</sup>).</p>\n<pre><code> 0. 1. 2. 3. 4. \n[2, 3, 1, 1, 4, 3, 2, 0, 1]\n 0  1  1  2  2  3  3  3  3\n\nclass Solution:\n    def jump(self, nums):\n        n = len(nums)  # 2\n        jumps = [float('inf')] * n  # [inf,inf]\n        jumps[0] = 0  # [0,-inf]\n        for i in range(n-1):  # 0,1\n            if jumps[n-1] != float('inf'):\n                break\n            for j in range(1, nums[i]+1):  # 1->1\n                if jumps[n-1] != float('inf'):\n                    break\n                if i+j &#x3C;= n-1:\n                    if jumps[i+j] == float('inf'):\n                      jumps[i+j] = jumps[i]+1\n        return jumps[n-1]\n\n\ns = Solution()\nprint(s.jump([2, 3, 1, 1, 4]))\n</code></pre>\n<h2 id=\"recursive-backtracking---not-working\" style=\"position:relative;\"><a href=\"#recursive-backtracking---not-working\" aria-label=\"recursive backtracking   not working permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Recursive Backtracking - Not Working</h2>\n<p>This is still pretty much the brute force method, just a different order, and much messier to implement (hence the broken code below).<br>\nThe idea is to try jumping the farthest possible value at each index (take the greedy approach) and see how many jumps it takes. Then, back-track to previous indexes and jump 1 less every time, and see how many jumps it takes. The downside is we’re still at a time complexity of O(n<sup>2</sup>)  because in the worst case scenario, we will still visit the length of the array at every index.</p>\n<pre><code class=\"language-py\"> 0. 1. 2. 3. 4. \n[2, 3, 1, 1, 4, 3, 2, 0, 1]\n 0  1  1. 2  2. 3        4 \n\n 0 1 2 3 4 5 6\n[4,1,1,3,1,1,1]\n 0     1 1 \ni = 0\njt = 4\nclass Solution:\n    def jump(self, nums):\n        jumps = [float('inf')] * len(nums)\n        jumps[0] = 0\n        i = 0\n\n        return self._recursion(0, nums, jumps)\n\n    def _recursion(self, i, nums, jumps):\n        while jumps[len(nums)-1] == float('inf'):\n            cur_val = nums[i]\n            if i + cur_val &#x3C;= len(nums)-1:\n                jump_to = i + cur_val\n            else:\n                jump_to = len(nums)-1\n            jumps[jump_to] = jumps[i] + 1\n            i = jump_to - 1\n            if jumps[i] == float('inf'):\n                jumps[i] = jumps[i+1]\n                self._recursion(i, nums, jumps)\n            else:\n                while jumps[i] != float('inf'):\n                    if i+1 &#x3C;= len(nums) -1:\n                        i += 1\n                    else:\n                        break\n            \n        return jumps[len(nums)-1]\n\ns = Solution()\nprint(s.jump([1,2,3]))\n</code></pre>\n<h1 id=\"dynamic-programming-solution\" style=\"position:relative;\"><a href=\"#dynamic-programming-solution\" aria-label=\"dynamic programming solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming Solution</h1>\n<h2 id=\"intuition-1\" style=\"position:relative;\"><a href=\"#intuition-1\" aria-label=\"intuition 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intuition</h2>\n<p>This is the most elegant solution, with best time &#x26; space complexity, but is a bit tricky to understand the intuition behind it.</p>\n<p>Essentially we try keep track of the farthest index that we <em>can</em> jump to at each index, always keeping the farthest value saved. Whenever But we don’t have to jump <em>until</em> we have used up all the “steps” that we can take. </p>\n<p>At index = 0, the number of steps we can take is always array[0], and the number of jumps we we take will be 1 (because we will do one jump right off the bat).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 125.53191489361701%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAZCAYAAAAxFw7TAAAACXBIWXMAAAsSAAALEgHS3X78AAAD7klEQVQ4y3VV2W4bRxD0/7/mA5KnAHlIgBxPSeDAgV8cx4ATXZZliYp5iHsfc+7sbG2ql1yGlBQIjdkZYXqquqqbLzAMGDCiD9uxSH7Ew/I7VNn3WP/zDXq3wp16i5/vvsDr9Vd4W3yNV/dfoum2vDHyamQM43G84OEYB0lYjmXyC4rkFer8NZLNr+i7HKld4N3yJ1xuf8dt9QZ/LV9C8XwcxjHGXUKuU+wTDvLSaLuIwo0wcUTdM7oRpe3hwggbBM2I6IHNMkXbKFRVhX0SWXFIOL+iVI0yeYnP6Xss2j9QFRWyLEWeZ4wUSrVoVYPVeoWqrmCtRd/3mNHNsUNIzoGJTWfg+oGUPCwR6m4gugDlA3jMsgSUZQljDLquk3vYMRzGRwjj2CiD9YTmHbSNuMjfYJF9Qt0YpKRXtwqWie7v77FcLtE0zTE6nCCUD4HfeQPdrhCIrNBL1DqH5kNKqYmehCSSvVCO3A+SbIcQR6IMo3YeieqgvUXtSiRGI9GatCmWlfNAMRrc3NygKApkZBNyolSOtsN/CWe4hgnqWiNPL+Db97jJ/8Qqu0KV1yh4WehqPiCUpY7ee/QsR7T+gPBIlEhRBugwwPeRqHoK06MN/V4kliMCzlkqn03JJlFmQ8cBj3w4jK02SPhy0VjW6BbX6Q8UhWgqhXwShbZhXF9fY7VaTT503gF7uicqyybQEs45aOPgbYJcXaPUDWlSFAbrT1T+RJS+C5Mwx0ofEBovoli0FKehBwsaPVcZGheRmQobs4Jih1xdXSFNU2w2G4SiRaz07MNTUaQumpSqisbVDqr+iDL7gLrU2OYLbPQ5LWQnuqKypoiB+50o8akongI0vocXcShCQxUaro77lt+BPd62DdFlU2mEei91w3Baw5my1CmtaJGygrIOOdfk4TciLHCbnmOlLlDSQmdnf0+2yfMcUvdhGP5HFBbX8mXDYjvSN/xudUZBiMZQhMA+50OzByXZ47Y7EUVQJa1Bw7V2gYJYpNy3JsFWpdjqNdq6xeXV5eRFEUZace/Fp5Q7QUU71JWMJkNhNNFkqNIzbMs7JvzIbvHT+JpsQwbPJpwhW3qqdB0sO6WlGDV7t6JIlsO24WOWomkmkkkjCQ2nT8+z47Y7oazZq9IReVFCGUtRSmzTgkIs8Wn9LT6rSzRVi/OLc+RZjvJ+PdlmeNwpM9wY+2mASo/KKiFCefrNlQm6wM4gahe6ieo0abh/zjYnB8drZBn6lH57aBAWFCFnZ8iEIdXuLkHPPo94SvkwdecfnGmVc7MfUb7braQo7Sb/76XtJsoybSIOrSfT4tkYpDryN+72ss4xzZij76N7/wIGaYmTGPWqpgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"45 jump game\"\n        title=\"45 jump game\"\n        src=\"/static/87a1344aa4a1d6a9d29c211c01a97bfa/1d69c/45_jump_game.png\"\n        srcset=\"/static/87a1344aa4a1d6a9d29c211c01a97bfa/4dcb9/45_jump_game.png 188w,\n/static/87a1344aa4a1d6a9d29c211c01a97bfa/5ff7e/45_jump_game.png 375w,\n/static/87a1344aa4a1d6a9d29c211c01a97bfa/1d69c/45_jump_game.png 750w,\n/static/87a1344aa4a1d6a9d29c211c01a97bfa/5d72a/45_jump_game.png 834w\"\n        sizes=\"(max-width: 750px) 100vw, 750px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"dp-code-on--o1\" style=\"position:relative;\"><a href=\"#dp-code-on--o1\" aria-label=\"dp code on  o1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DP Code: O(n) / O(1)</h2>\n<pre><code class=\"language-python\">class Solution:\n    def jump(self, array):\n        \"\"\"\n        Given an array of numbers, return the minimum number of jumps needed to reach the last index.\n        Assume starting point is index=0, and the jump distance at each index i is array[i].\n        Assume it is always possible to reach the last index.\n        array type: List[int]\n        rtype: int\n        \"\"\"\n        # edge case: array is empty or length is 1\n        if array == [] or array == None or len(array) == 1:\n            return 0\n        # start jumping from index 0 and keep track of the farthest we've jumped\n        jumps = 1\n        farthest = array[0]\n        steps_left = array[0]\n        for i in range(1,len(array)-1):\n            farthest = max(array[i]+i, farthest)\n            steps_left -= 1\n            if steps_left == 0:\n                jumps += 1\n                steps_left = farthest - i\n        return jumps\n\ns = Solution()\nprint(s.jump([1,2,3])) # 2\nprint(s.jump([0])) # 0\nprint(s.jump([2,3,1])) # 1\nprint(s.jump([2,3,1,1,4])) # 2\nprint(s.jump([2,3,1,1,4,3,2,0,1])) # 3\nprint(s.jump([7,0,9,6,9,6,1,7,9,0,1,2,9,0,3])) # 2\n</code></pre>"}},"pageContext":{"slug":"45_Jump_Game_II"}}}