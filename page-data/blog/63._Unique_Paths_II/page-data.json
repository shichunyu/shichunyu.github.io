{"componentChunkName":"component---src-templates-blog-js","path":"/blog/63._Unique_Paths_II","result":{"data":{"markdownRemark":{"frontmatter":{"title":"Unique Paths II","date":"2020-06-01T00:00:00.000Z"},"html":"<div class=\"toc\">\n<ul>\n<li><a href=\"#dynamic-programming-solution\">Dynamic Programming Solution</a></li>\n</ul>\n</div>\n<p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p>\n<p><img src=\"./63_Unique_Paths_II/robot_maze.png\"></p>\n<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p>\n<p>Now consider if some obstacles are added to the grids. How many unique paths would there be?</p>\n<p>An obstacle and empty space is marked as 1 and 0 respectively in the grid.</p>\n<p>::Note: m and n will be at most 100.::</p>\n<p><strong>Example 1:</strong></p>\n<pre><code>Input:\n[\n  [0,0,0],\n  [0,1,0],\n  [0,0,0]\n]\nOutput: 2\nExplanation:\nThere is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n</code></pre>\n<h1 id=\"dynamic-programming-solution\" style=\"position:relative;\"><a href=\"#dynamic-programming-solution\" aria-label=\"dynamic programming solution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Dynamic Programming Solution</h1>\n<p><strong>Runtime:</strong> O(w*h) where w= width of array, h = height of array\n<strong>Space:</strong> O(w*h) where w= width of array, h = height of array</p>\n<pre><code class=\"language-py\">class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        Returns the number of all possible unique paths for a given 2D matrix where 0s are valid cells and 1s are obstacles.\n        Start at the top left and move either right or down at any given cell. The destination is the bottom right cell.\n        obstacleGrid type: List[List[int]]\n        rtype: int\n        \"\"\"\n        \n        # edge case: obstacleGrid is empty\n        if obstacleGrid is None:\n            return -1\n        if obstacleGrid == []:\n            return -1\n        \n        width = len(obstacleGrid[0])\n        height = len(obstacleGrid)\n\n        # create our grid to store our answers in for each cell\n        paths = [[0] * width for _ in range(height)]\n        print(paths)\n        \n        # edge case: target cell is blocked\n        if obstacleGrid[height-1][width-1] != 1:\n           paths[height-1][width-1] = 1\n\n        # fill in grid values of bottom edge and right edge based on the value of their neighbors\n        for col in range(width-2,-1,-1):\n            if obstacleGrid[height-1][col] != 1:\n                paths[height-1][col] = paths[height-1][col+1]\n        for row in range(height-2,-1,-1):\n            if obstacleGrid[row][width-1] != 1:\n                paths[row][width-1] = paths[row+1][width-1]\n        print(paths)\n\n        # populate grid based on value which is sum of right neightbor and bottom neighbor\n        for col in range(width-2,-1,-1):\n            for row in range(height-2,-1,-1):\n                if obstacleGrid[row][col] != 1:\n                    paths[row][col] = paths[row+1][col] + paths[row][col+1]\n        print(paths)\n        return paths[0][0]\n\n\ns = Solution()\nprint(s.uniquePathsWithObstacles([[0,0],[1,1],[0,0],[0,0]])) # 0\nprint(s.uniquePathsWithObstacles([[0,0]])) # 1\nprint(s.uniquePathsWithObstacles([[1,0]])) # 0\nprint(s.uniquePathsWithObstacles([[[0,0],[1,0]]])) # 1\nprint(s.uniquePathsWithObstacles([])) # -1\nprint(s.uniquePathsWithObstacles([[1]])) # 0\nprint(s.uniquePathsWithObstacles([\n  [0,0,0],\n  [0,0,0],\n  [0,0,0]\n])) # 6\n</code></pre>"}},"pageContext":{"slug":"63._Unique_Paths_II"}}}