{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0000 Flood Fill","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>Flood Fill</h1>\n<h2>Flood Fill</h2>\n<p>!Graphs, !BFS</p>\n<p>An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p>\n<p>Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, \"flood fill\" the image.</p>\n<p>To perform a \"flood fill\", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p>\n<p>At the end, return the modified image.</p>\n<pre><code class=\"language-text\">Example 1:\nInput: \nimage = [[1,1,1],[1,1,0],[1,0,1]]\nsr = 1, sc = 1, newColor = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: \nFrom the center of the image (with position (sr, sc) = (1, 1)), all pixels connected \nby a path of the same color as the starting pixel are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected\nto the starting pixel.\n</code></pre>\n<h3>Note:</h3>\n<p>The length of image and image[0] will be in the range [1, 50]. The given starting pixel will satisfy 0 &#x3C;= sr &#x3C; image.length and 0 &#x3C;= sc &#x3C; image[0].length. The value of each color in image[i][j] and newColor will be an integer in [0, 65535].</p>\n<h2>âœ… BFS @shichunyu on May 11, 2020</h2>\n<pre><code class=\"language-python\">from collections import deque\n\nclass Solution:\n    def floodFill(self, image, sr, sc, new_color):\n        # get the color of the current block\n        old_color = image[sr][sc] # color: 1\n        if old_color == new_color:\n            return image\n        first_px = [sr,sc]\n        # queue up the current block\n        queue = deque()\n        queue.append(first_px)\n        while queue:\n            cur_px = queue.popleft() # [sr,sc]\n            # change color of current block\n            image[cur_px[0]][cur_px[1]] = new_color\n            # get the neighbors of current block\n            dirs = {(0,1),(1,0),(0,-1),(-1,0)}\n            for dir in dirs:\n                new_r = cur_px[0] + dir[0]\n                new_c = cur_px[1] + dir[1]\n                # make sure 1) we're not off the map 2) should be same as old_color\n                if (0 &#x3C;= new_r &#x3C; len(image) and \n                    0 &#x3C;= new_c &#x3C; len(image[0]) and \n                    image[new_r][new_c] == old_color):\n                    queue.append([new_r,new_c])\n        return image\n\nif __name__ == '__main__':\n    s = Solution()\n    # image1 = [[1,1,1],[1,1,0],[1,0,1]]\n    # print(s.floodFill(image1, 1, 1, 2))\n    image2 = [[0, 0, 0], [0, 1, 1]]\n    print(s.floodFill(image2, 1, 1, 1))\n</code></pre>"}},"pageContext":{"slug":"0000 Flood Fill"}}}