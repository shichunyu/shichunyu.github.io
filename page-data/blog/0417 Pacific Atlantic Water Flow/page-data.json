{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0417 Pacific Atlantic Water Flow","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>0417. Pacific Atlantic Water Flow</h1>\n<h2>417. Pacific Atlantic Water Flow</h2>\n<p>Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the \"Pacific ocean\" touches the left and top edges of the matrix and the \"Atlantic ocean\" touches the right and bottom edges.</p>\n<p>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</p>\n<p>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>\n<h3>Note:</h3>\n<p>The order of returned grid coordinates does not matter. Both m and n are less than 150.</p>\n<pre><code class=\"language-text\">Example:\n\nGiven the following 5x5 matrix:\n\n  Pacific ~   ~   ~   ~   ~ \n       ~  1   2   2   3  (5) *\n       ~  3   2   3  (4) (4) *\n       ~  2   4  (5)  3   1  *\n       ~ (6) (7)  1   4   5  *\n       ~ (5)  1   1   2   4  *\n          *   *   *   *   * Atlantic\n\nReturn:\n\n[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).\n</code></pre>\n<h2>DFS @shichunyu on May 17, 2020</h2>\n<p><code>Time &#x26; Space Complexity</code> Runtime: 388 ms, faster than 23.87 % of Python3 online submissions for Pacific Atlantic Water Flow. Memory Usage: 15.4 MB, less than 10.00 % of Python3 online submissions for Pacific Atlantic Water Flow.</p>\n<pre><code class=\"language-python\">from collections import defaultdict\n\nclass Solution:\n    def pacificAtlantic(self, matrix):\n        \"\"\"\n        type matrix: List[List[int]]\n        rtype: List[List[int]]\n        \"\"\"\n\n        # Edge case of no matrix\n        if matrix == []:\n            return []\n\n        pacific = set()\n        atlantic = set()\n        status_pacific = defaultdict()\n        status_atlantic = defaultdict()\n\n        ROWS = len(matrix)\n        COLS = len(matrix[0])\n\n        pacific_edges = set( [(i,0) for i in range(ROWS)] + [(0,j) for j in range(COLS)] )\n        atlantic_edges = set( [(i,COLS-1) for i in range(ROWS)] + [(ROWS-1,j) for j in range(COLS)] )\n\n\n        print('pacific edges: ' + str(pacific_edges))\n        print('atlantic edges: ' + str(atlantic_edges))\n\n        # traverse Pacific\n        for row, col in pacific_edges:\n            cur_node = (row, col)\n            self.traverse(matrix, pacific, cur_node, status_pacific)\n\n        # traverse Atlantic\n        for row, col in atlantic_edges:\n            cur_node = (row, col)\n            self.traverse(matrix, atlantic, cur_node, status_atlantic)\n\n        ans = pacific.intersection(atlantic)\n        print('reaches pacific: ' + str(pacific))\n        print('reaches atlantic: ' + str(atlantic))\n        return ans\n\n    def traverse(self, matrix, target_ocean, cur_node, target_status):\n        directions = [(1,0), (-1,0), (0,1), (0,-1)]\n        target_status[cur_node] = 'visited'\n        cur_val = matrix[cur_node[0]][cur_node[1]]\n        for dir in directions:\n            neighbor = (cur_node[0]+dir[0],cur_node[1]+dir[1])\n            if (0 &#x3C;= neighbor[0] &#x3C; len(matrix)\n                and 0 &#x3C;= neighbor[1] &#x3C; len(matrix[0]) ):\n                val_neighbor = matrix[neighbor[0]][neighbor[1]]\n                if val_neighbor >= cur_val and neighbor not in target_status:\n                    self.traverse(matrix, target_ocean, neighbor, target_status)\n            else:\n                continue\n        target_ocean.add(cur_node)\n\ns = Solution()\n\n# matrix = []\n\n# # matrix = [\n# #     [1,2],\n# #     [2,1],\n# # ]\n# print('ans: ' + str(s.pacificAtlantic(matrix)))\n\n\n# matrix = [\n#     [1, 1],\n#     [1, 1],\n#     [1, 1],\n# ]\n\n# print('ans: ' + str(s.pacificAtlantic(matrix)))\n\nmatrix = [\n    [1,2,2,3,5],\n    [3,2,3,4,4],\n    [2,4,5,3,1],\n    [6,7,1,4,5],\n    [5,1,1,2,4],\n]\n\n# matrix = [\n#     [3,2,3],\n#     [2,1,4],\n#     [0,2,4],\n# ]\n\nprint('ans: ' + str(s.pacificAtlantic(matrix)))\n</code></pre>\n<h2>Leetcode BFS Solution</h2>\n<pre><code class=\"language-python\">DIRECTIONS = ((1, 0), (-1, 0), (0, 1), (0, -1))\n\nclass Solution:\n    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:\n        if not matrix or not matrix[0]:\n            return []\n\n        m = len(matrix)\n        n = len(matrix[0])\n\n        atlantic = set([(m - 1, bottom) for bottom in range(n)] + [(row, n - 1) for row in range(m)])\n        pacific = set([(i, 0) for i in range(m)] + [(0, i) for i in range(n)])        \n\n        def explore_oceans(start_cells):\n            frontier = set(start_cells)\n            visited = set()\n\n            while frontier:\n                land = frontier.pop()\n                land_r, land_c  = land\n                visited.add(land)\n\n                for dr, dc in DIRECTIONS:\n                    next_r, next_c = land_r + dr, land_c + dc\n                    new_land = (next_r, next_c)\n                    is_valid = (0 &#x3C;= next_r &#x3C; m and 0 &#x3C;= next_c &#x3C; n\n                                and new_land not in visited\n                                and new_land not in frontier\n                                and matrix[next_r][next_c] >= matrix[land_r][land_c])\n\n                    if is_valid:\n                        frontier.add(new_land)\n\n            return visited\n\n        return list(explore_oceans(pacific) &#x26; explore_oceans(atlantic))\n</code></pre>"}},"pageContext":{"slug":"0417 Pacific Atlantic Water Flow"}}}