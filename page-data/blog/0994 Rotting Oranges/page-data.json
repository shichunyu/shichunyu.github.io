{"componentChunkName":"component---src-templates-blog-js","path":"/blog/0994 Rotting Oranges","result":{"data":{"markdownRemark":{"frontmatter":{"title":"","date":null},"html":"<h1>0994. Rotting Oranges</h1>\n<h2>994. Rotting Oranges</h2>\n<p><a href=\"https://leetcode.com/problems/rotting-oranges/\">https://leetcode.com/problems/rotting-oranges/</a></p>\n<p>In a given grid, each cell can have one of three values:</p>\n<p>the value 0 representing an empty cell; the value 1 representing a fresh orange; the value 2 representing a rotten orange. Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>\n<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.</p>\n<pre><code class=\"language-text\">Example 1:\nInput: [[2,1,1],[1,1,0],[0,1,1]]\nOutput: 4\n</code></pre>\n<pre><code class=\"language-text\">Example 2:\nInput: [[2,1,1],[0,1,1],[1,0,1]]\nOutput: -1\nExplanation:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n</code></pre>\n<pre><code class=\"language-text\">Example 3:\nInput: [[0,2]]\nOutput: 0\nExplanation:  Since there are already no fresh oranges at minute 0, the answer is just 0.\n</code></pre>\n<h3>Note:</h3>\n<p>1 &#x3C;= grid.length &#x3C;= 10 1 &#x3C;= grid[0].length &#x3C;= 10 grid[i][j] is only 0, 1, or 2.</p>\n<h2>Leetcode Solution</h2>\n<pre><code class=\"language-python\">from collections import deque\nclass Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        queue = deque()\n\n        # Step 1). build the initial set of rotten oranges\n        fresh_oranges = 0\n        ROWS, COLS = len(grid), len(grid[0])\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 2:\n                    queue.append((r, c))\n                elif grid[r][c] == 1:\n                    fresh_oranges += 1\n\n        # Mark the round / level, _i.e_ the ticker of timestamp\n        queue.append((-1, -1))\n\n        # Step 2). start the rotting process via BFS\n        minutes_elapsed = -1\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n        while queue:\n            row, col = queue.popleft()\n            if row == -1:\n                # We finish one round of processing\n                minutes_elapsed += 1\n                if queue:  # to avoid the endless loop\n                    queue.append((-1, -1))\n            else:\n                # this is a rotten orange\n                # then it would contaminate its neighbors\n                for d in directions:\n                    neighbor_row, neighbor_col = row + d[0], col + d[1]\n                    if ROWS > neighbor_row >= 0 and COLS > neighbor_col >= 0:\n                        if grid[neighbor_row][neighbor_col] == 1:\n                            # this orange would be contaminated\n                            grid[neighbor_row][neighbor_col] = 2\n                            fresh_oranges -= 1\n                            # this orange would then contaminate other oranges\n                            queue.append((neighbor_row, neighbor_col))\n\n        # return elapsed minutes if no fresh orange left\n        return minutes_elapsed if fresh_oranges == 0 else -1\n\nif __name__ = '__main__':\n    # test cases\n    s = Solution()\n    print(s.orangesRotting([[2,1,1],[1,1,0],[0,1,1]])) # 4\n    print(s.orangesRotting([[0, 2]]))  # 0\n    print(s.orangesRotting([[2, 1, 1], [0, 1, 1], [1, 0, 1]]))  # 0\n</code></pre>"}},"pageContext":{"slug":"0994 Rotting Oranges"}}}